"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InvalidEventDataError = void 0;
exports.parseWebhookEvent = parseWebhookEvent;
const miniapp_core_1 = require("@farcaster/miniapp-core");
const jfs_ts_1 = require("./jfs.js");
const types_ts_1 = require("./types.js");
class InvalidEventDataError extends types_ts_1.BaseError {
    name = 'VerifyJsonFarcasterSignature.InvalidEventDataError';
}
exports.InvalidEventDataError = InvalidEventDataError;
// Support legacy frame_* event names by mapping them to miniapp_*
const LEGACY_EVENT_MAP = {
    frame_added: 'miniapp_added',
    frame_removed: 'miniapp_removed',
    frame_add_rejected: 'miniapp_add_rejected',
};
async function parseWebhookEvent(rawData, verifyAppKey) {
    const { fid, appFid, payload } = await (0, jfs_ts_1.verifyJsonFarcasterSignature)(rawData, verifyAppKey);
    // Pase and validate event payload
    let payloadJson;
    try {
        payloadJson = JSON.parse(Buffer.from(payload).toString('utf-8'));
    }
    catch (error) {
        throw new InvalidEventDataError('Error decoding and parsing payload', error instanceof Error ? error : undefined);
    }
    const normalizedPayload = payloadJson && typeof payloadJson.event === 'string'
        ? {
            ...payloadJson,
            event: LEGACY_EVENT_MAP[payloadJson.event] ?? payloadJson.event,
        }
        : payloadJson;
    const event = miniapp_core_1.serverEventSchema.safeParse(normalizedPayload);
    if (event.success === false) {
        throw new InvalidEventDataError('Invalid event payload', event.error);
    }
    return { fid, appFid, event: event.data };
}
